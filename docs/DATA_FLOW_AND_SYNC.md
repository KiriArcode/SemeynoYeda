# Поток данных, синхронизация и связи сущностей

Документ фиксирует: что происходит после создания/обновления меню, правила генерации плана заготовок, гипотезу по 13 ошибкам синхронизации, поведение списка покупок и защиту от дубликатов, главный источник истины по спискам, а также уточняющие вопросы для постановки задачи.

---

## 1. Состояние плана «Menu generation and editing»

По файлу [menu_generation_and_editing_37cddd48.plan.md](.cursor/plans/menu_generation_and_editing_37cddd48.plan.md):

| Задача | Статус |
|--------|--------|
| Кнопка «Из шаблона» → надпись изменена на «創建列表», по нажатию создаётся меню | ✅ Сделано |
| Swap → случайное блюдо (без модалки) | ❌ Не реализовано — по клику открывается SwapModal |
| Кнопка «Сгенерить меню» (из базы с учётом прошлой недели) | ❌ Нет — есть только создание из seed-шаблона |
| Меню прошлой недели / getByWeekStart | ❌ Нет — только getCurrent() |
| Алгоритм генерации в menuGenerator.ts | ❌ Нет |
| Удаление/добавление блюда в приёме (кнопки в MealSlot) | ❌ Не описано в коде |
| Лайк/дизлайк из меню (обновление рецепта по Wabba) | ❌ Нет — useWabba только на странице Wabba |

Итог: из плана реализованы только создание меню из шаблона и сохранение правок слотов (handleMealSlotUpdate). Остальное — в плане, но не в коде.

---

## 2. Что происходит после «創建列表» (создание меню из шаблона)

- Вызывается `createMenuFromTemplate()`:
  - `getSeedWeekMenu()` создаёт меню на текущую неделю (Пн–Пт из seed, Сб–Вс пустые).
  - `dataService.menus.create(menu)` пишет в IndexedDB и ставит `_sync: pending`.
  - Вызывается `loadWeekMenu()` → отображается новое меню.

Что **не** делается автоматически:

- **Список покупок** — не пересчитывается и не очищается. Старый список остаётся. Генерация списка покупок из меню выполняется только:
  - на странице «Покупки» при монтировании (если есть меню и настройки `autoGenerate`) — `autoGenerateList()`;
  - по кнопке «Обновить список» на странице покупок — `handleRegenerate()`.
- **План заготовок (PrepPlan / BatchPlan)** — не пересоздаётся и не сбрасывается. Если план по заготовкам уже был и частично выполнен:
  - он остаётся в БД (по дате);
  - при открытии страницы «Заготовки» подставляются рецепты из **текущего** меню, но загрузка/сохранение плана привязаны к дате и к тому, что уже есть в `prepPlans`/batch plan;
  - частично выполненные задачи не сбрасываются при смене меню.

То есть после нажатия «創建列表»: меню новое, список покупок и план заготовок могут оставаться от старой недели/старого меню, пока пользователь явно не перегенерирует список или план.

---

## 3. Правила генерации плана по заготовкам

В коде два типа планов:

### 3.1 PrepPlan (usePrepPlan) — задачи подготовки ингредиентов

- **Источник:** рецепты, переданные в `generatePrepPlan(recipes, date)` (например, из PrepBlock по дню).
- **Правила:**
  - Берутся шаги рецепта с `!step.equipment` или `step.duration < 5`.
  - Для таких шагов ищутся упоминания ингредиентов в `step.text`; по ним создаются задачи (нарезка, маринад, замачивание и т.д.).
  - Группировка по ключу `ingredient_action_group`; одинаковые объединяются (сумма amount, список recipeId).
  - Группы: vegetables, grains, dairy, meat, other; порядок: canPrepareAhead сначала, затем по группе.

### 3.2 BatchPlan (useBatchCooking) — план batch cooking на PrepPage

- **Источник:** текущее недельное меню (`dataService.menus.getCurrent()`).
- **Уровни вложенности (nestingLevel):**
  - **1** — рецепты из меню: теги `freezable`, `prep-day`, `batch-cooking`; соусы (`category === 'sauce'`) с `freezable`/`prep-day`.
  - **2** — компоненты уровня 1: ингредиенты рецептов меню, совпадающие по названию с рецептами из базы (бульоны, соусы, супы: `prep-day`/`freezable`/`sauce`/`soup`).
  - **3** — компоненты уровня 2: ингредиенты рецептов уровня 2, снова совпадающие с рецептами (напр. бульон внутри соуса).
- **Слияние со старым планом при генерации:**
  - Загружается последний сохранённый план. Выполненные задачи старого плана: если рецепт есть в новом плане — соответствующие новые задачи помечаются выполненными; если рецепта нет в новом плане — задача добавляется в конец списка как **orphan** (`isOrphan: true`) с кнопкой **«Удалить»**.
  - **Удалить (орфан):** задача убирается из плана. Если рецепт требует заморозки — из списка заготовок удаляется, но запись в морозилке не трогается. Если не требует заморозки — просто удаляется из списка.
- Фазы по оборудованию (grinder/mixer → stove/oven → blender → vacuum). План сохраняется в `db.batchPlans` (локально), не синхронизируется с Neon.

---

## 4. Синхронизация: откуда могут браться 13 ошибок

- Ошибки — это записи с `_sync.syncStatus === 'error'` во всех таблицах (recipes, menus, freezer, shopping, prepPlans, cookingSessions, chefSettings). Их количество показывает SyncStatus как «Ошибки синхронизации (13)».

**Исправление 409 Duplicate recipe:** в `syncService` при синхронизации рецептов, если `createInNeon` выбрасывает ошибку с текстом «Duplicate» или «Conflict» (API возвращает 409 — рецепт уже есть в Neon, например seed-рецепты), вызывается `updateInNeon` вместо создания, после чего запись помечается как `synced`. Так счётчик ошибок для таких рецептов перестаёт расти и после успешного sync обнуляется.

Вероятные причины (до исправления):

1. **Рецепты seed / после Wabba**  
   Wabba вызывает `dataService.recipes.update(id, { wabbaRatings, suitableFor?, excludedFromMenu?, updatedAt })`. Если в API/Neon нет полей `wabbaRatings`, `suitableFor`, `excludedFromMenu` или их типы/ограничения отличаются, то при `syncToNeon('recipes')` ответ будет ошибкой, и запись получит `syncStatus: 'error'`. Несколько таких рецептов дают несколько ошибок.

2. **Shopping: ключ по `ingredient`**  
   В IndexedDB и API ключ — `ingredient` (название). Генерация списка объединяет по `name_unit`; в объекте хранится `ingredient: name`. Если в одном списке есть один и тот же `ingredient` с разными `unit`, при `bulkPut` в IndexedDB вторая запись перезапишет первую. При синхронизации в Neon уходит то, что осталось в IndexedDB; дубликаты по имени с разными единицами могли до этого дать конфликт или неожиданное поведение на бэкенде.

3. **PrepPlans**  
   Обновление идёт по `id` плана. Если на бэкенде другой ключ (например, date) или обязательные поля отличаются, возможны ошибки при create/update.

4. **Menus**  
   После создания меню из шаблона новая запись идёт в Neon как create. Если API ожидает другую структуру (например, вложенные дни/слоты), возможны 4xx/5xx и ошибка синхронизации для этого меню.

Рекомендация: в DevTools проверить `_sync` у записей с `syncStatus === 'error'` (таблица и `errorMessage`), затем сверить с контрактом API и схемой Neon.

---

## 5. Как изменяется список покупок

- **Генерация из меню:**  
  На странице покупок при наличии меню и опции авто-генерации вызывается `generateShoppingList(weekMenu)` (и опционально `missingIngredients`). Результат записывается через `dataService.shopping.bulkPut(newItems)` — то есть список **полностью заменяется** сгенерированным набором (плюс при необходимости добавленные «missing»).

- **Ручное добавление:**  
  `addItem` → `dataService.shopping.create(newItem)` — одна новая строка.

- **Добавление отсутствующих (из готовки):**  
  `addMissingIngredients(missing)` — по именам ингредиентов; если такого `ingredient` ещё нет в списке, добавляется новая запись с `source: 'missing'`.

- **Регенерация по кнопке:**  
  Снова `generateShoppingList(menu)` + `bulkPut` — опять полная замена списка содержимым, рассчитанным по текущему меню.

При создании нового меню («創建列表») список покупок сам по себе не обновляется — пока пользователь не откроет страницу покупок с авто-генерацией или не нажмёт «Обновить список».

---

## 6. Защита от дубликатов в списке покупок

- **При генерации (useShoppingList.generateShoppingList):**  
  Дубликаты объединяются по ключу **`${ingredient.name}_${ingredient.unit}`** (name + unit). Один ключ = одна позиция в `ingredientMap` с суммой `totalAmount` и списком `recipeIds`. То есть защита от дубликатов на этапе генерации — по паре (название, единица).

- **В хранилище (IndexedDB и API):**  
  Первичный ключ — только **`ingredient`** (название). Единица измерения хранится в поле `unit`, но не входит в ключ. Поэтому:
  - два сгенерированных элемента «лук» (г и шт) при `bulkPut` дадут две записи с одинаковым ключом `ingredient: "лук"` — в IndexedDB останется одна (последняя при put).
  - при синхронизации в Neon уходит одна запись на «лук»; вторая единица теряется.

Итог: защита от дубликатов при генерации — по (name, unit); в БД и при синхронизации — только по (ingredient name). Это может приводить к потере данных (разные единицы для одного названия) и к расхождению с API, если там ожидается уникальность по (ingredient, unit).

---

## 7. Консольные логи при обновлении меню

Добавлено в [MenuPage.tsx](src/pages/MenuPage.tsx):

- **Создание меню из шаблона:**  
  `console.log('[MenuPage] createMenuFromTemplate: start')` в начале;  
  после успешного create: `console.log('[MenuPage] createMenuFromTemplate: menu created', { id, weekStart })`;  
  при ошибке: `console.error('[MenuPage] createMenuFromTemplate: failed', error)`.

- **Обновление слота (редактирование дня/приёма):**  
  `console.log('[MenuPage] handleMealSlotUpdate', { dayDate, mealIndex, recipeIds })` до сохранения;  
  после успешного update: `console.log('[MenuPage] handleMealSlotUpdate: menu saved', { menuId })`.

По ним можно отслеживать порядок действий и факт сохранения меню при использовании «創建列表» и правок в слотах.

---

## 8. Взаимосвязи и главный список (источник истины)

Желаемые связи:

- **Меню недели (WeekMenu)** — главный источник для производных данных на эту неделю:
  - список покупок должен строиться из **текущего** меню (getCurrent или меню по weekStart текущей недели);
  - план заготовок (BatchPlan / PrepPlan по дате) должен строиться из рецептов **этого же** меню.
- **Список покупок** — производный от меню при «генерации»; ручные и «missing» позиции — дополнение. Логично считать главным список, привязанный к одному меню (например, к weekStart или к флагу shoppingListGenerated у меню), и при смене меню — явно пересчитывать или помечать список устаревшим.
- **План заготовок** — привязан к дате (и к меню на эту неделю). Главный источник — меню; план должен пересчитываться при смене меню для этой недели, с явным решением: сбрасывать ли выполненные задачи или сохранять их отдельно.

Сейчас:

- Единственный «главный» список по меню — это само **WeekMenu** (getCurrent). Список покупок и планы заготовок не привязаны к нему по ID/weekStart в коде; связь только по факту «берём рецепты из текущего меню» в момент генерации. После «創建列表» старый список покупок и старый план заготовок остаются, пока пользователь не перегенерирует их вручную.

---

## 9. План действий для исправления состояния

1. **Кнопка и логи (сделано)**  
   - Надпись «Из шаблона» заменена на «創建列表», по нажатию создаётся меню.  
   - Добавлены console.log при создании и обновлении меню.

2. **Синхронизация (13 ошибок)**  
   - Посмотреть в IndexedDB записи с `_sync.syncStatus === 'error'`: таблица, id/ingredient, `errorMessage`.  
   - Сверить с API/Neon: наличие и типы полей у recipes (wabbaRatings, suitableFor, excludedFromMenu), формат menus/shopping/prepPlans.  
   - Исправить контракт или миграции и при необходимости повторно отправить изменения (retry или ручной sync).

3. **Список покупок**  
   - Определиться: ключ в БД только `ingredient` или (ingredient + unit).  
   - Если нужны разные единицы для одного названия — сменить первичный ключ (например, составной или id) в схеме и в sync.  
   - После создания нового меню: либо автоматически пересчитывать список из нового меню, либо показывать предупреждение «Меню изменилось, обновите список покупок».

4. **План заготовок**  
   - Зафиксировать: при смене меню (в т.ч. «創建列表») пересоздаём план на неделю или оставляем старый и только помечаем «по старому меню».  
   - Если пересоздаём — решить, сбрасывать ли completedTasks или переносить по идентификаторам задач.

5. **План из .cursor/plans**  
   - По желанию: реализовать «Сгенерить меню» из базы с учётом прошлой недели, swap по клику без модалки, удаление/добавление блюда в слоте, лайк/дизлайк из меню — по приоритету.

---

## 10. Уточняющие вопросы для постановки задачи

1. **Список покупок после «創建列表»:**  
   Нужно ли сразу пересчитывать список покупок по новому меню (и перезаписывать текущий список) или оставлять старый и только предлагать пользователю «Обновить список»?

2. **План заготовок после смены меню:**  
   При новом меню на неделю: полностью перегенерировать план (и сбрасывать выполненные задачи) или сохранять старый план и показывать предупреждение, что он от старого меню?

3. **13 ошибок синхронизации:**  
   Есть ли доступ к логам бэкенда/Neon или к ответам API при sync? Можете ли выписать из IndexedDB для 2–3 записей с error: таблицу, ключ и `_sync.errorMessage` — чтобы точно сопоставить с API?

4. **Главный источник истины для списка покупок:**  
   Должен ли список покупок быть жёстко привязан к одному меню (например, weekStart) и при открытии страницы «Покупки» всегда показывать список, сгенерированный для текущего меню, или допускается «свободный» список с ручными правками и одной генерацией по кнопке?

5. **Дубликаты в списке покупок:**  
   Нужна ли поддержка одного и того же ингредиента в разных единицах (например, «мука» в г и в кг) как двух отдельных строк? Если да — нужно менять ключ в БД (например, на id или ingredient+unit).

6. **Wabba и рецепты в меню:**  
   Если после Wabba рецепт получает `excludedFromMenu: true`, нужно ли автоматически убирать его из текущего меню (и обновлять слоты) или только не показывать в следующих генерациях?

Ответы на эти вопросы позволят зафиксировать правила синхронизации и поведения списка покупок/плана заготовок так, чтобы приложение оставалось предсказуемым при большом объёме данных.
